# Начните использовать ngrx/effects для этого

[Оригинал статьи](https://blog.angularindepth.com/start-using-ngrx-effects-for-this-e0b2bd9da165) [Справочник RxJS](https://stackblitz.com/edit/rxjs-aj4vwd)

Скорее всего, вы используете библиотеку эффектов (ngrx/Effects) только для коммуникации с внешним источником, вызывая побочный эффект (ngrx/Effect) с помощью действия (ngrx/Action). Но знаете ли вы, что библиотеку эффектов можно использовать для чего-то ещё?

## ngrx/Effects

Библиотека эффектов предоставляет способ изолировать побочные эффекты в своей собственной модели, вне хранилища (ngrx/Store) и компонентов `Angular`. Она предоставляет нам наблюдаемые действия (Observable/actions), проще говоря - поток (stream) всех отправленных (dispatched) действий. Для каждого отправленного действия она вызывает редуктор (ngrx/Reducer), и создаёт новое значение. Она также предоставляет `RxJS` оператор `ofType`, который используется для фильтрации действий по их типу.

Типичный эффект использует наблюдаемые действия в качестве источника и использует оператор ofType для выполнения своего побочного эффекта только при отправке соответствующего действия. Например, мы хотим получить список клиентов из внешнего ресурса. Для этого нам нужно создать эффект `getCustomers`. Этот эффект прослушивает каждое отправляемое действие, и когда он получает действие с типом `[Customers Page] Get`, то он отправляет HTTP-запрос. В зависимости от ответа эффект будет отправлять действие `GetCustomersSuccess`, если запрос был успешным, или действие `GetCustomersFailed`, если запрос вернул ошибку. Чтобы найти клиентов, мы должны отправить действие `GetCustomers`. Внутри нашего компонента, где мы хотим показать список всех клиентов, мы должны использовать селектор, чтобы выбрать всех клиентов из состояния хранилища.

https://gist.github.com/bskydive/a4a4f33594ef2fa47bd09165418806ea

## 1. Внешние ресурсы

Наблюдаемые действия являются наиболее известным, и наиболее часто используемым источником ваших эффектов. Однако, мы можем использовать любой наблюдаемый объект (Observable) в качестве источника.

### Используем наблюдаемые объекты RxJS

https://gist.github.com/bskydive/39de05ae9361db7583ce1de8b355e7d6

### Используем JavaScript API и RxJS

https://gist.github.com/bskydive/1165813718dcebbbf52893ab89240692

### Используем Angular Material CDK

https://gist.github.com/bskydive/2e16038f53ab20354e48f982de472ada

## 2. Перехват действий диалоговых окон Angular Material

Вместо обработки действий диалога внутри компонента можно использовать эффект. Эффект определяет, когда открывать и закрывать диалог, и отправляет действие с результатом диалога.

https://gist.github.com/bskydive/e3de25ad54a90b4d7edddba2b5742243

## 3. Показываем уведомления

Обработка уведомлений внутри эффекта делает остальную часть вашего приложения чистой и более понятной. Рассмотрим пример окна напоминалки на базе [Snackbar](https://material.angular.io/components/snack-bar/overview) `Angular Material`.

https://gist.github.com/bskydive/0b2bf15e190c4d69aa380a7ec47b1cb7

Или окна ошибки

https://gist.github.com/bskydive/5f17644e2072dc14fbd4e0fabff03e05

## 4. Используем селектор внутри эффектов

Иногда вам нужно получить доступ к состоянию хранилища(ngrx\Store) внутри эффекта. Для этого мы можем использовать оператор `RxJS withLatestFrom` в сочетании с селектором для получения фрагмента(slice) состояния хранилища.

https://gist.github.com/bskydive/2f2dfba12a9e121b42ca9d6cf5da27e1

Чтобы сделать следующий шаг, мы можем использовать данные, полученные селектором, чтобы проверить, существует ли уже сущность в хранилище. Это дает нам возможность блокировать ненужные запросы `GET`, если объект уже сохранен в хранилище.

https://gist.github.com/bskydive/2c38fee1833d2cac022250164d169fee

## 5. Навигация на основе действий

Внедряя(inject) маршрут(Angular router) в эффекты, можно перенаправить пользователя на основе определенных действий. В приведенном ниже примере мы отправляем пользователя на домашнюю страницу, когда он или она выходит из системы.
Обратите внимание, что мы передаем `@Effect({dispatch:false})`, потому что мы не отправляем никакого события. Если бы мы этого не сделали, мы бы застряли в бесконечном цикле, потому что эффект повторяет одно и то же действие снова и снова.

https://gist.github.com/bskydive/25bf82d780d32c5294961af3b825a6e7

## 6. Аналитика / мониторинг

Поскольку каждое отправленное действие генерирует новое значение для источника действий, мы можем использовать этот источник для получения статистики приложения. Мы можем регистрировать все действия или некоторые, фильтруя их с помощью оператора `ofType`. В приведенном ниже примере мы регистрируем каждое действие в `appInsights`.

https://gist.github.com/bskydive/b5d18622d7cecccc7f6d8defcac3eaac

## Заключение

Используя эти способы, мы можем переместить часть кода из наших компонентов или `ngrx/Store`, в модель `ngrx/Effects`. Это сделает компоненты более чистыми, и поможет хранить побочные эффекты нашего приложения отдельно. В результате получается код, который легче понимать и тестировать.
Теперь, когда вы знаете, в каких случаях эффекты можно использовать, стоит посмотреть когда этого делать не стоит.

> Примечание переводчика: примеры кода дополнены комментариями, исправлены незначительные ошибки, текст незначительно сокращён для более литературно красивого перевода.
