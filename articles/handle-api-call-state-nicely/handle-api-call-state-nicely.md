# Обрабатываем вызовы api изящным образом

[Оригинал](https://blog.angularindepth.com/handle-api-call-state-nicely-445ab37cc9f8)

В этой статье я расскажу о способе обработки состояний для вызовов API и сокращения стандартного шаблона путем сбора общей логики в абстракцию. Этот способ мощный, чистый, и менее подвержен ошибкам. В этой статье предполагается, что мы используем [NgRx](https://ngrx.io/) для управления состоянием.

Бьюсь об заклад, что наличие API вызовов являются одним из самых распространенных требований для веб-разработки. Многие приложения имеют массу API вызовов. С точки зрения пользовательского опыта всегда полезно указывать состояние вызова API, например, показывать крутилку или сообщение об ошибке. Я видел много способов моделирования состояния вызова API и нашел одну главную проблему: **тяжелый шаблон**, который обычно вызывает дальнейшие проблемы.

## Тяжелый шаблон

Предположим следующие бизнес требования:

1. Отправить запрос API, чтобы получить список сегодняшних новостей.
2. Показать крутилку во время загрузки
3. Показать загруженный список новостей при успешной загрузке.

Многие разработчики проектируют модель состояния с двумя действиями (скажем, `LoadNews` и `LoadNewsSuccess`, и двумя обработчиками редуктора для изменения состояния `loading` и `entities`).

https://gist.github.com/vvscode/d6a5b7b9f2cacf41a2fad2c82bb69737

Пока что мы не видим здесь никаких проблем. Это крепкий «стандарт».

Допустим, у нас есть 20 (или даже больше) запросов API в этом приложении. Теперь появляются проблемы:

1. **Много шаблонов.** Нам нужно обработать состояние API `loading` 20 раз, сделать 40 действий и 40 обработчиков в редукторах. Это много кода с повторяющейся логикой.

2. **Несогласованное именование.** Допустим, 20 вызовов API реализованы 4 разработчиками. Они могут иметь разные соглашения об именах. Например, загрузка может называться `isLoading`, `waiting`, `isWaiting`, `started` и т. д.

На самом деле, приведенная выше модель состояния API имеет только одно состояние `loading`. Однако предполагается, что полный набор будет иметь больше состояний API (о которых пойдет речь в следующем разделе), что сделает предыдущие 2 пункта еще хуже.

Давайте решим эту проблему изящно.

## Что такое полный набор состояний?

Полный цикл вызовов API может иметь следующие состояния:

1. Вызов API не запущен
2. Вызов API начался, но ответа пока нет
3. API-вызов получил успешный ответ
4. Вызов API получил ответ об ошибке

Таким образом, мы можем спроектировать общую модель загрузки следующим образом (назовем ее `Loadable`):

https://gist.github.com/vvscode/62aa2e016985146aebdafe9975bf1096

4 состояния легко сопоставить со значениями 3 полей.

Я бы также создал 4 простых вспомогательных функции для обновления загружаемого состояния. Обратите внимание, что они являются чистыми функциями и возвращают новые объекты `loadable`:

https://gist.github.com/vvscode/ff778eb6a6293113da7faa3de0a12f66

## Применим `loadable` к нашему примеру загрузки списка новостей

### Модель

Помимо 3 полей `loadable`, нам нужно еще одно состояние для хранения списка новостей, которые мы получили от API. Итак, мы можем предположить следующую модель:

https://gist.github.com/vvscode/96d6d97982982902eebac2a67c54b0de

### Действия (actions)

Действия остаются такими же, как в соглашениях ngrx.

https://gist.github.com/vvscode/f072c49ad3c96608706a1856db83a88e

### Редуктор (reducer)

Мы используем редуктор, чтобы изменить состояние в соответствии с 3 различными действиями.

https://gist.github.com/vvscode/7925f8974782385c0ff1ec3cb51e3143

### Побочные эффекты (effects)

https://gist.github.com/vvscode/c7859854ffb5730c0c795b80999dbf92

### UI Component

https://gist.github.com/vvscode/c2dba4384244345b18f794a39cb7354c

Кода достаточно, чтобы заставить его работать. Тем не менее, это помогает только обеспечить согласованное именование за счет наследования `loadable`, и помогает убедиться в правильности изменения состояния с помощью вспомогательных функций. Это действительно не уменьшает шаблон. Представьте, что если у нас есть 20 вызовов API, нам все равно нужно обрабатывать каждое действие (load, loadSuccess, loadError) в каждом из 20 редукторов. И 20 из них имеют одинаковую логику смены состояний. (то есть `loading` `success` `error`)

## Абстрактная логика изменения состояния API для редуктора

Давайте определим функцию более высокого порядка `withLoadable`, которая принимает в качестве параметров редуктор, три строки типа действия, и возвращает новый улучшенный редуктор.

https://gist.github.com/vvscode/693f36f8729b9833cc019c7114166342

Таким образом, редуктор для новостей может быть таким:

https://gist.github.com/vvscode/1217a30f324807841bfd8a321ea87e11

`baseNewsReducer` обрабатывает не `loadable` состояния (то есть `entities`)

`newsReducer` на самом деле будет применять `withLoadable` к `baseReducer`, чтобы придать `baseReducer` немного «магии», т.е. способность **автоматически** обрабатывать изменения состояния `loadable`.

Таким образом, если у нас есть 20 вызовов API, и мы хотим сохранить все 20 * 3 = 60 состояний, мы можем просто применить `withLoadable` к 20 базовым редукторам. В 20 базовых редукторах нас не волнует, как должно обновляться состояние `loadable`. Таким образом, это экономит нам много времени на ручное обновление состояния API.

## Бонус: подключение `loadable` в компонент пользовательского интерфейса

На самом деле `Loadable` обеспечивает действительно согласованный контракт, так что он может быть беспрепятственно связан с глобальным компонентом пользовательского интерфейса. Например, я могу создать общий `loadable-container` компонента для обработки пользовательского интерфейса загрузки, глобальный интерфейс ошибок. И единственный контракт с внешним миром - это просто  `Loadable` в `@Input`

https://gist.github.com/vvscode/d69ebd7a35376d8336a0190e5397ad3c

Это позволит нам обрабатывать каждую крутилку/ошибку вызова API, просто используя этот компонент `loadable-container`, что также экономит множество кода в шаблонах.

https://gist.github.com/vvscode/6cf2e112ab59a80999867376fce228a5

Пожалуйста, найдите окончательный код в [StackBlitz](https://stackblitz.com/github/zhaosiyang/loadable-example) или в [Github Repo](https://github.com/zhaosiyang/loadable-example). Единственное отличие от кода статьи в том, что он более строго организован, чтобы показать лучшие практики кодирования в реальной жизни. Кроме того, он использует ложный вызов API для получения списка новостей.

Если вы хотите использовать его в своем проекте, у меня есть пакет npm для вас. Смотрите  [тут](https://www.npmjs.com/package/loadable-state).

> Примечание переводчика: примеры кода дополнены комментариями, исправлены незначительные ошибки, текст незначительно сокращён для более литературно красивого перевода.
